<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2013-04-01T00:00:00Z</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Building Single Page Applications and CORS</title>
    <link rel="alternate" href="/2013/04/01/building_single_page_applications_and_cors.html"/>
    <id>/2013/04/01/building_single_page_applications_and_cors.html</id>
    <published>2013-04-01T00:00:00Z</published>
    <updated>2013-04-01T00:00:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;A while back I promised some insight on CORS &lt;a href='/2012/08/26/accessing_server_data_from_a_native_android_app.html'&gt;here&lt;/a&gt; and it&amp;#8217;s about time I delivered. Few things have changed since then, I worked a bit on the Play framework and found it to be quite nice and also a lot of project requests in my day job now ask for a web application and a &amp;#8220;native&amp;#8221; mobile application (atleast one that works well on tablets).&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;A while back I promised some insight on CORS &lt;a href='/2012/08/26/accessing_server_data_from_a_native_android_app.html'&gt;here&lt;/a&gt; and it&amp;#8217;s about time I delivered. Few things have changed since then, I worked a bit on the Play framework and found it to be quite nice and also a lot of project requests in my day job now ask for a web application and a &amp;#8220;native&amp;#8221; mobile application (atleast one that works well on tablets).&lt;/p&gt;

&lt;p&gt;Building web applications that also work on tablets can be done in many ways but over a period of time I have realized it&amp;#8217;s good to create separate applications for server side and client side logic. While the server side serves JSON (and talks to the data store) the client side takes care of rendering the UI.&lt;/p&gt;

&lt;p&gt;While both of these jobs can be done in a single Play / Rails application the advantage of the two component approach is that the client side app can be easily packaged later into a PhoneGap application and served as a native app. It also makes sure that the app is written cleanly and the sepraration of concerns is maintained. Ofcourse, this approach has it&amp;#8217;s disadvantages as it is not a very scalable way to write code but if the requirement is to create simple &amp;#8220;Single Page Applications&amp;#8221; it works well.&lt;/p&gt;

&lt;p&gt;So in this blog we will talk about such an application which uses Scala + Play on the server side and on the client side we will use my favorite stack of Require.js and Backbone.js.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://yeoman.io'&gt;Yeoman.io&lt;/a&gt; is a collection of tools which makes building client heavy application easy. It takes care of creating, building, minifying our client side code among other things. You can head over to &lt;a href='http://yeoman.io'&gt;Yeoman.io&amp;#8217;s site&lt;/a&gt; to learn to create a simple web application and can easily add libraries like Backbone by running the following command -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bower install --save backbone&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As evident, adding libraries / components with Yeoman is trivial and the application it builds out the box uses Require.js etc. which makes life easy. Once you run &amp;#8220;grunt server&amp;#8221; it serves your application through a node.js server and developing and testing the app is also simplified due to node.js&amp;#8217;s speed and automatic refresh.&lt;/p&gt;

&lt;p&gt;Moving back to the server side (Play) we want our server to just send over JSON so our controller could look something like -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def data = Action {
  Ok(Json.obj(&amp;quot;message&amp;quot; -&amp;gt; (&amp;quot;Hello World!&amp;quot;) )) // Or get data from DB backed model etc.
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the correct routing added if we go to &lt;strong&gt;http://localhost:9000/data&lt;/strong&gt; we get a JSON greeting (our Play application runs on port 9000).&lt;/p&gt;

&lt;p&gt;Now on our client side, which is running on the Node.js server (and can later be packaged in PhoneGap) we need to access this data and maybe display it. Without going into the details of Backbone we can define our model as -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define [&amp;quot;jquery&amp;quot;, &amp;quot;underscore&amp;quot;, &amp;quot;backbone&amp;quot;], ($, _, Backbone) -&amp;gt;
  &amp;#39;use strict&amp;#39;
  
  class RemoteModel extends Backbone.Model

    url: -&amp;gt;
      &amp;quot;http://localhost:9000/data&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And for the Backbone View -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define [&amp;quot;jquery&amp;quot;, &amp;quot;underscore&amp;quot;, &amp;quot;backbone&amp;quot;, ], ($, _, Backbone) -&amp;gt;
  &amp;#39;use strict&amp;#39;
  
  class RemoteView extends Backbone.View
    
    el: &amp;quot;.remote-message&amp;quot;

    render: -&amp;gt;
      @model.fetch({async: false})
      $(@el).html(JSON.stringify @model)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when we do -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require([&amp;#39;remoteview&amp;#39;, &amp;#39;remotemodel&amp;#39;, &amp;#39;jquery&amp;#39;, &amp;#39;bootstrap&amp;#39;], function (RemoteView, RemoteModel, $) {
    &amp;#39;use strict&amp;#39;;

    $(function () {
        var model = new RemoteModel();
        new RemoteView({model: model}).render();
    });
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should see the JSON from the server on our client application. Ofcourse, this won&amp;#8217;t work as the Node.js server is different from the Play server and security policies do now allow cross-origin requests. These restrictions prevent a client-side Web application running from one server from obtaining data retrieved from another server (which is a good thing) but in our case we want this to be allowed.&lt;/p&gt;

&lt;p&gt;So we head over to &lt;a href='http://www.w3.org/TR/cors/'&gt;W3C site&lt;/a&gt; to see how this can be enabled. All we need to do is to add this header to our Play server&amp;#8217;s response -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ACCESS_CONTROL_ALLOW_ORIGIN: &amp;quot;http://localhost:8000&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We allow requests from &amp;#8220;http://localhost:8000&amp;#8221; since our client side application is running there, in case we have to PhoneGap the app there is no server on the client side so we will need to allow the &amp;#8220;null&amp;#8221; origin as well (trivial to do).&lt;/p&gt;

&lt;p&gt;Now to add this header to our Play application, we could do something like this -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def data = Action {
  Ok(Json.obj(&amp;quot;message&amp;quot; -&amp;gt; (&amp;quot;Hello from Play!&amp;quot;) )).withHeaders(ACCESS_CONTROL_ALLOW_ORIGIN -&amp;gt; &amp;quot;http://localhost:8000&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, adding the header to each and every Action is a pain so we can simply do this in our Global class -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;object Global extends GlobalSettings {

  /**
   * Global action composition.
   */
  override def doFilter(action: EssentialAction): EssentialAction = EssentialAction { request =&amp;gt;
    action.apply(request).map(_.withHeaders(
      ACCESS_CONTROL_ALLOW_ORIGIN -&amp;gt; &amp;quot;http://localhost:8000&amp;quot;
    ))
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;#8217;s it! Our server side JSON can now be used on our client app.&lt;/p&gt;

&lt;p&gt;&lt;img alt='Yeoman and Play' src='/images/yeoman_and_play.png' /&gt;&lt;/p&gt;

&lt;p&gt;Now, for the production setup, we can serve our client side application from plain NGINX (after buiding it from Yeoman/Grunt) and the same code can be served in a PhoneGap application as well in case we want a more &amp;#8220;native&amp;#8221; application. The Play server meanwhile serves both these application from a sigle (or clustered) instance and we get awesome &lt;a href='http://www.techempower.com/blog/2013/03/28/framework-benchmarks/'&gt;speed&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;p.s. Play here can be substituted with Rails as well.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Integrating Rails and Node.js via Redis</title>
    <link rel="alternate" href="/2013/03/22/integrating_node_and_rails_with_redis.html"/>
    <id>/2013/03/22/integrating_node_and_rails_with_redis.html</id>
    <published>2013-03-22T00:00:00Z</published>
    <updated>2013-03-22T00:00:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;It&amp;#8217;s been a while since I blogged, not really for the lack of content but rather the lack of time. I travelled to beautiful Berlin in Jan-Feb and was also doing the Coursera course &lt;a href='https://www.coursera.org/course/algo'&gt;https://www.coursera.org/course/algo&lt;/a&gt; which pretty much ate up all my weekends. Well here is a pic of beautiful Berlin pretty close to where I worked.&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;It&amp;#8217;s been a while since I blogged, not really for the lack of content but rather the lack of time. I travelled to beautiful Berlin in Jan-Feb and was also doing the Coursera course &lt;a href='https://www.coursera.org/course/algo'&gt;https://www.coursera.org/course/algo&lt;/a&gt; which pretty much ate up all my weekends. Well here is a pic of beautiful Berlin pretty close to where I worked.&lt;/p&gt;

&lt;p&gt;&lt;img alt='Berlin' src='/images/berlin.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;Berlin was awesome and I had a great time there but I moved back to India a couple of weeks back and also completed my Coursera course. Finally had some free time this week, so here goes.&lt;/p&gt;

&lt;p&gt;I had been exploring Node.js earlier and found it blazingly fast but couldn&amp;#8217;t really use it as my main backend. However I wanted to use Node&amp;#8217;s websocket capabilites while using Rails for my main application so I started exploring how to integrate the two. Redis has a pretty good PubSub mechanism which is pretty fast and stable so I looked into Redis as the intermediatory between Node and Rails and built a real-time chat application.&lt;/p&gt;

&lt;p&gt;You may wonder, why build a chat application and why use Rails? Well not to start any arguments, &lt;strong&gt;I&lt;/strong&gt; think Rails is an excellent framework, it has a great ecosystem and helps build web applications at a great pace. JRuby also solves the Ruby slowness problem to a large extent. Node.js on the other hand is excellent for websocket communication so I chose both of them. I built a Chat application because it provides a mix of real-time and standard request-response communication. While the chat is real-time, user registration, room creation etc. works well on Rails.&lt;/p&gt;

&lt;p&gt;Lets get started, the applications works as follows -&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Users register and login with a Rails application.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Users can create chatrooms and invite other users for a chat. The user and chat room data is stored in MySql.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;When in a chat room, user sends a message via an AJAX POST request.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;The message is received by the server.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I wanted processing to be asynchronous from here on so I chose Torquebox. Torquebox provides HornetQ (a JMS implementation) and the message is posted on a Topic (if you remember Queues &amp;amp; Topics from messaging systems :) )&lt;/li&gt;

&lt;li&gt;There are two consumers for this topic. Consumer one takes the message and inserts it into a MongoDB collection while consumer two posts the message on Redis PubSub channel.&lt;/li&gt;

&lt;li&gt;The advantage of this setup is that these two tasks are done asynchronously and in parallel.&lt;/li&gt;

&lt;li&gt;While MongoDB will give me the chat history when I need it, Redis notifies my Node.js application that a new message has arrived.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Once message is posted on the Redis PubSub channel, it is picked up by the Node.js application (listening on the Redis channels) and based on the channel (each chatroom has its own PubSub channel) socket.io raises an event on the chatroom&amp;#8217;s websocket channel.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Two channels here, one for Redis PubSub and one for websocket communication.&lt;/li&gt;

&lt;li&gt;Also we don&amp;#8217;t want users in chatroom 1 listening to messages on chatroom 2.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;On the client side the message is received via the websocket push, parsed and displayed on the HTML DOM.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pictorially this can be represented as -&lt;/p&gt;

&lt;p&gt;&lt;img alt='chatapp_arch' src='/images/chatapp_arch.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;The application looks like -&lt;/p&gt;

&lt;p&gt;&lt;img alt='chatapp1' src='/images/chatapp1.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='chatapp2' src='/images/chatapp2.png' /&gt;&lt;/p&gt;

&lt;p&gt;Well what do we have in the end? We have a pretty basic Rails app that has Node&amp;#8217;s awesome real-time capabilities, is scalable (JRuby, Torquebox, HornetQ, Redis) and most importantly scratches my itch.&lt;/p&gt;

&lt;p&gt;For client side I also used Backbone.js and Require.js to keep things clean. Finally the source code is here - &lt;a href='https://github.com/rocky-jaiswal/chatapp'&gt;https://github.com/rocky-jaiswal/chatapp&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Please note this is not in perfect shape in any way. The user invitation is very basic (only for existing users) and most components (Redis, Torquebox, Node, MongoDB, HornetQ) need to be clustered to provide fault tolerance. But I hope this will provide a nice base for anyone who is looking to utilize the development speed of Rails and the real-time awesomeness of Node.js.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Backbone.js and CoffeeScript - A Perfect Match</title>
    <link rel="alternate" href="/2012/12/13/backbone_and_coffeescript.html"/>
    <id>/2012/12/13/backbone_and_coffeescript.html</id>
    <published>2012-12-13T00:00:00Z</published>
    <updated>2012-12-13T00:00:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;As I started learning more about JavaScript I was very impressed with CoffeeScript. It felt like JavaScript done right! But with time, as my JavaScript concepts improved I was a bit reluctant to write CoffeeScript. &amp;#8220;Why learn one language that produces another when you can write the end product directly?&amp;#8221; Also, my head could do without another set of syntax and rules to learn.&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;As I started learning more about JavaScript I was very impressed with CoffeeScript. It felt like JavaScript done right! But with time, as my JavaScript concepts improved I was a bit reluctant to write CoffeeScript. &amp;#8220;Why learn one language that produces another when you can write the end product directly?&amp;#8221; Also, my head could do without another set of syntax and rules to learn.&lt;/p&gt;

&lt;p&gt;However, when I started writing code for &lt;a href='http://backbonejs.org/'&gt;Backbone.js&lt;/a&gt; a few months back, it dawned on me that CoffeeScript is a beautiful language and makes writing Backbone.js apps a much more pleasant experience.&lt;/p&gt;

&lt;p&gt;But first of all, why did I need Backbone.js? I was happy writing jQuery, it was solving all my problems but then the interface and the callbacks got more complex and one day my JavaScript file had more than 200 lines of code. I was pretty sure this was going to be a maintenance headache no matter how well I name my functions and how many comments I add. So I refactored the code to Backbone.js and had a handful of small, cleanly coded files that were easy to test and modify. So that&amp;#8217;s that, a one line answer - we use Backbone.js to keep our JavaScript code clean.&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s take a simple example, assume you have a button, clicking on which makes an AJAX call and displays the result from the AJAX call back in a div. This is a simple use case for a Backbone.js.&lt;/p&gt;

&lt;p&gt;The JavaScript and Backbone.js code for this may look like -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//&amp;lt;div id=&amp;quot;container&amp;quot;&amp;gt;
  //&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;btn1&amp;quot; value=&amp;quot;Go!&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
//&amp;lt;/div&amp;gt;
//&amp;lt;span id=&amp;quot;message&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;

$(function(){

  var ButtonBarView = Backbone.View.extend({

    el: &amp;#39;#container&amp;#39;,

    events: {
      &amp;quot;click #btn1&amp;quot;:  &amp;quot;makeAjaxCall&amp;quot;
    },

    makeAjaxCall: function(){
      console.log(&amp;quot;making an ajax call ...&amp;quot;);
      this.options.messageView.render(&amp;quot;result from ajax call&amp;quot;);
    }

  });

  var MessageView = Backbone.View.extend({

    el: &amp;#39;#message&amp;#39;,

    render: function(message){
      var html = &amp;quot;&amp;lt;h3&amp;gt;&amp;quot; + message + &amp;quot;&amp;lt;/h3&amp;gt;&amp;quot;;
      this.$el.html(html); 
    }

  });

  var messageView = new MessageView();
  var buttonBarView = new ButtonBarView({messageView: messageView});

});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing much to explain here, we could have done the same thing using just jQuery but things go awry when there are ten such buttons on the screen each with its own AJAX call and DOM to update.&lt;/p&gt;

&lt;p&gt;In the example above we create two Backbone views, on an event on the first one we render the second with the returned message.&lt;/p&gt;

&lt;p&gt;Same thing written in CoffeeScript looks like this -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ -&amp;gt;

  class ButtonBarView extends Backbone.View

    el: &amp;#39;#container&amp;#39;

    events: 
      &amp;quot;click #btn1&amp;quot;:  &amp;quot;makeAjaxCall&amp;quot;

    makeAjaxCall: -&amp;gt;
      console.log(&amp;quot;making an ajax call ...&amp;quot;)
      @options.messageView.render(&amp;quot;result from ajax call&amp;quot;)

  class MessageView extends Backbone.View

    el: &amp;#39;#message&amp;#39;

    render: (message) -&amp;gt;
      html = &amp;quot;&amp;lt;h3&amp;gt;&amp;quot; + message + &amp;quot;&amp;lt;/h3&amp;gt;&amp;quot;
      $(@el).html(html)

  messageView = new MessageView()
  buttonBarView = new ButtonBarView({messageView: messageView})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To me the CoffeeScript code looks much more understandable and cleaner. But wait, do we see a &amp;#8220;class&amp;#8221; in the CoffeeScript code! How is that possible? And how does the &amp;#8220;class&amp;#8221; in CoffeeScript convert the code to the one written in JavaScript? Exploring this made me realize CoffeeScript&amp;#8217;s beauty and brevity.&lt;/p&gt;

&lt;p&gt;To answer the first question, we need to understand a bit of JavaScript and CoffeeScript magic. JavaScript is an object oriented language but does not have classes, it uses the prototypal inheritance mechanism to extend objects. CoffeeScript uses this mechanism to give us classes, for example -&lt;/p&gt;

&lt;p&gt;This code -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person

  constructor: (@name) -&amp;gt;

  printName: -&amp;gt;
    console.log(&amp;quot;Name: &amp;quot; + @name)

#rocky = new Person(&amp;quot;Rocky&amp;quot;)
#rocky.printName(); &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gets converted to something like this in JavaScript -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Person = (function() {

  function Person(name) {
    this.name = name;
  }

  Person.prototype.printName = function() {
    return console.log(&amp;quot;Name: &amp;quot; + this.name);
  };

  return Person;

})();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What this does is it returns us a &amp;#8220;constructor&amp;#8221; callback which can be used with the &lt;strong&gt;new&lt;/strong&gt; keyword to create objects. CoffeeScript also uses JavaScript&amp;#8217;s prototype mechanism to add methods to our object. However, the end user creates classes and methods like they do in their server side code. This is an AWESOME CoffeeScript feature that had me completely floored.&lt;/p&gt;

&lt;p&gt;Now the second question, how does this -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MessageView extends Backbone.View&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;relate to this -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MessageView = Backbone.View.extend({})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To answer this lets see what happens to the CoffeeScript code when it gets converted to JavaScript -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var __hasProp = {}.hasOwnProperty,
__extends = function(child, parent) { 
  for (var key in parent) { 
    if (__hasProp.call(parent, key)) child[key] = parent[key]; 
  } 
  function ctor() { this.constructor = child; } 
  ctor.prototype = parent.prototype; 
  child.prototype = new ctor(); 
  child.__super__ = parent.prototype; 
  return child; 
};

var MessageView = (function(_super) {

  __extends(MessageView, _super);

  function MessageView() {
    return MessageView.__super__.constructor.apply(this, arguments);
  }

  return MessageView;

})(Backbone.View);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again JavaScript has no built in inheritance support so we fake it using it&amp;#8217;s functional and prototypical features. The &lt;strong&gt;extends&lt;/strong&gt; function generated and called by CoffeeScript behind the scene enables us to &amp;#8220;extend&amp;#8221; our class from Backbone&amp;#8217;s View.&lt;/p&gt;

&lt;p&gt;The end result is that Backbone code written in CoffeeScript is much more easier on the eye. In turn Backbone makes our JavaScript code much easier to maintain. So the combination of the two gives us code that is simple, clean and easy to maintain which is every developer&amp;#8217;s dream come true :)&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Serving Rails from Windows</title>
    <link rel="alternate" href="/2012/12/02/serving_rails_from_windows.html"/>
    <id>/2012/12/02/serving_rails_from_windows.html</id>
    <published>2012-12-02T00:00:00Z</published>
    <updated>2012-12-02T00:00:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;I was asked to meet quite a &amp;#8220;non-standard&amp;#8221; requirement lately - the client wanted me to serve a Rails application from a Windows server. The application was not very complicated and has only a handful of users so I agreed to give it a shot. While doing this was relatively simple, I decided to blog about it in case it helps anyone.&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;I was asked to meet quite a &amp;#8220;non-standard&amp;#8221; requirement lately - the client wanted me to serve a Rails application from a Windows server. The application was not very complicated and has only a handful of users so I agreed to give it a shot. While doing this was relatively simple, I decided to blog about it in case it helps anyone.&lt;/p&gt;

&lt;p&gt;I decided to go with JRuby as anything that works on JVM theoretically should run on any OS. So I got hold of a clean Windows machine and installed -&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JDK 1.7&lt;/li&gt;

&lt;li&gt;Postgres-9.1&lt;/li&gt;

&lt;li&gt;Apache Tomcat 7&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want to run the build on the Windows machine, you would also need -&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JRuby 1.7&lt;/li&gt;

&lt;li&gt;Git 1.8 for Windows&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now if your application is a simple Rails application you don&amp;#8217;t have to worry too much, any gem written in Ruby would work well on JRuby. Some gems written in C do not work well on JRuby however JRuby has good alternatives for these too, so just check the gems you are using if they have any C extensions (this is rare so I will not go into details). Since we also want to switch to JDBC drivers for JRuby, I added the following to my Gemfile -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#JRuby specific gems
platform :jruby do
  gem &amp;#39;activerecord-jdbcpostgresql-adapter&amp;#39;, :git =&amp;gt; &amp;#39;https://github.com/jruby/activerecord-jdbc-adapter&amp;#39;
  gem &amp;#39;jruby-openssl&amp;#39;
  gem &amp;#39;jruby-pageant&amp;#39;
  gem &amp;#39;warbler&amp;#39;
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are building the application on Windows, you should have Git and JRuby on the server. Open the git bash terminal and run -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install bundler
git clone &amp;lt;your repo here&amp;gt;
bundle install&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should run fine. Note the &amp;#8216;jruby-pageant&amp;#8217; gem we added to the Gemfile, this was one special gem I installed to get the application working on Windows.&lt;/p&gt;

&lt;p&gt;Now run -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bundle exec warble config&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will generate a warble.rb file in you application&amp;#8217;s config folder. This file has numerous config options, read it to understand more but usually I just change two values -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Set JRuby to run in 1.9 mode.
config.webxml.jruby.compat.version = &amp;quot;1.9&amp;quot;

# Value of RAILS_ENV for the webapp -- default as shown below
config.webxml.rails.env = ENV[&amp;#39;RAILS_ENV&amp;#39;] || &amp;#39;production&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is self explanatory stuff. You can also create a custom environment to deploy to Windows if you want.&lt;/p&gt;

&lt;p&gt;Now run -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bundle exec rake assets:precompile
bundle exec warble&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will compile your Rails assets and generate a (application-name).war file in your project with all files in the right place. For the non Java folks a .war file is a web archive file that is like a compressed folder that can be copied and deployed to a JEE application server.&lt;/p&gt;

&lt;p&gt;Assuming you have created the DB with the database.yml settings for the production environment, now go to your Tomcat installation directory and within that look for the &amp;#8220;webapps&amp;#8221; directory.&lt;/p&gt;

&lt;p&gt;To keep our lives simple delete the ROOT folder in this directory and copy the .war we created as ROOT.war here. We do this so that the routes we created in our Rails app do not have to deal with an extra context path if we deploy the app with any other name. ROOT folder in webapps maps to the path &amp;#8220;http://localhost:8080/&amp;#8221; so our application&amp;#8217;s routes remain intact. Please note that if you do not want to build the application on Windows this is the only step you need to do.&lt;/p&gt;

&lt;p&gt;Run the apache-tomcat/bin/startup script from your favoured terminal and checkout the logs created in apache-tomcat/logs folder. In case you have missed anything the catalina.out logs will tell you the problem.&lt;/p&gt;

&lt;p&gt;You can create a proxy for tomcat using Apache HTTP server if you want. Tomcat specific config like the port on which it is running can be found in apache-tomcat/conf/server.xml.&lt;/p&gt;

&lt;p&gt;Also the above steps can be put in a script that can be run from cygwin. That is it, this is all you need to serve a Rails application from Windows. To my surprise I found that the response times were also very good.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Why does JavaScript require Require.js</title>
    <link rel="alternate" href="/2012/10/15/why_does_js_require_requirejs.html"/>
    <id>/2012/10/15/why_does_js_require_requirejs.html</id>
    <published>2012-10-15T00:00:00Z</published>
    <updated>2012-10-15T00:00:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;Around a week back I started learning about Require.js after someone recommened it to me. When I looked at the &lt;a href='http://requirejs.org/'&gt;website&lt;/a&gt; I was not very impressed. My initial reaction was &amp;#8221;&lt;strong&gt;what is require.js trying to solve / why should I use it / how will it make my life better?&lt;/strong&gt;&amp;#8221;&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Around a week back I started learning about Require.js after someone recommened it to me. When I looked at the &lt;a href='http://requirejs.org/'&gt;website&lt;/a&gt; I was not very impressed. My initial reaction was &amp;#8221;&lt;strong&gt;what is require.js trying to solve / why should I use it / how will it make my life better?&lt;/strong&gt;&amp;#8221;&lt;/p&gt;

&lt;p&gt;I simply moved on, but I also realized that as we are writing more and more JavaScript these days, we need to organize it better. In OO languages such as Java and Ruby we organize code by putting it in classes and maybe having a policy of one class per file, then we load the classes in other classes via dependency loading mechanisms built into the language (like import / require).&lt;/p&gt;

&lt;p&gt;JavaScript although being OO has no classes, via CoffeeScript we can still create classes in JavaScript by leveraging the prototype mechanism in JavaScript (but that is perhaps another blog topic) but as our JS code gets bigger how do I organize it and manage dependencies. So I started searching the web for ways to do so. My search led me &lt;a href='http://addyosmani.com/largescalejavascript'&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To summarize the article, one of the most common ways to orgainize JS code is through object literals -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//apple.js
var apple = {
  type: &amp;quot;macintosh&amp;quot;,
  color: &amp;quot;red&amp;quot;,
  getInfo: function () {
      return this.color + &amp;#39; &amp;#39; + this.type + &amp;#39; apple&amp;#39;;
  }
}
//console.log(apple.color)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Put a literal in a file and load it in your html. This is the stating point for most developers. Another popular mechanism which kind of builds upon this is Modules -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var basketModule = (function() {
  var basket = []; //private
  return { //exposed to public
    addItem: function(values) {
      basket.push(values);
    },
    getItemCount: function() {
      return basket.length;
    },
    getTotal: function(){
      var q = this.getItemCount(),p=0;
      while(q--){
        p+= basket[q].price; 
      }
      return p;
    }
  }
}());&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The advantage of the module pattern is that unlike literals you can expose certain things (what is returned) while some things can be private (like the basket array in example above).&lt;/p&gt;

&lt;p&gt;Cool so we have some basic ways to organize our JavaScript, however how do we load these JavaScripts and how do we manage the dependencies. Usually we do it this way -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;Module1.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Module2.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Module3.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Module4.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Module5.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Module8.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- want to use 6 in 8... --&amp;gt;
&amp;lt;script src=&amp;quot;Module6.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Module7.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;Module8.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is horrible, we load the JavaScript files in HTML and manually order them. If tomorrow things change we have to manually change the order or add or remove files. This is definitely not the way to build good software. Rails asset pipelining tries to solve this but there is still no way to manage JS dependencies.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Require.js&lt;/strong&gt; addresses this exact problem.&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/amdjs/amdjs-api/wiki/AMD'&gt;AMD&lt;/a&gt; is a specification which JavaScript developers created and proposed so that the JavaScript dependency management and loading problem is addressed across all JS libraries. Require.js is an impelementation of this specification. We create modules like above but we follow certain syntax to load the dependencies -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//my shirt.js now has some dependencies, a cart and inventory
//module in the same directory as shirt.js
define([&amp;quot;./cart&amp;quot;, &amp;quot;./inventory&amp;quot;], function(cart, inventory) {
    //return an object to define the &amp;quot;my/shirt&amp;quot; module.
    return {
      color: &amp;quot;blue&amp;quot;,
      size: &amp;quot;large&amp;quot;,
      addToCart: function() {
        inventory.decrement(this);
        cart.add(this);
      }
    }
  }
);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;define() is the main function require.js provides, we use it to define a module, we first pass an array of dependencies for the module then a function to define the module. We also follow the one module per file policy&lt;/p&gt;

&lt;p&gt;Another simple example (in CoffeeScript) would be to place the following code in a file common.coffee&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define [], -&amp;gt;

  # What is the enter key constant?
  ENTER_KEY: 13&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now whenever you want to use the &amp;#8220;common&amp;#8221; module just include it as a dependency (like cart in example above).&lt;/p&gt;

&lt;p&gt;Finally in our HTML we need to just reference one JavaScript file (please see comments in code below) -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;My Sample Project&amp;lt;/title&amp;gt;
    &amp;lt;!-- data-main attribute tells require.js to load scripts/main.js after require.js loads. --&amp;gt;
    &amp;lt;script data-main=&amp;quot;scripts/main&amp;quot; src=&amp;quot;scripts/require.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In your main.js file you can use require() function to load the JavaScripts. Example Backbone setup -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require([
  &amp;#39;views/app&amp;#39;,
  &amp;#39;routers/router&amp;#39;
], function( AppView, Workspace ) {
  // Initialize routing and start Backbone.history()
  new Workspace();
  Backbone.history.start();

  // Initialize the application view
  new AppView();
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is it! After this the other modules will load their dependencies on their own (since they are &amp;#8220;defined&amp;#8221; via require.js).&lt;/p&gt;

&lt;p&gt;Finally since some libs are not using define() like jQuery / Backbone how do we load them. The answer lies in &lt;a href='http://requirejs.org/docs/api.html#config-shim'&gt;shims&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For a sample project that uses Require.js, Backbone.js, jQuery and CoffeeScript see - &lt;a href='https://github.com/rocky-jaiswal/todo-js'&gt;this&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Rails on only JVM</title>
    <link rel="alternate" href="/2012/09/22/rails_on_only_jvm.html"/>
    <id>/2012/09/22/rails_on_only_jvm.html</id>
    <published>2012-09-22T00:00:00Z</published>
    <updated>2012-09-22T00:00:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;Imagine a scenario where an IT operations team is just comfortable with JVM. You also need to deliver a quick five day project and you know that Rails is just the right framework for it. But you do not have the luxury of installing Ruby or even Sqlite on the server.&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Imagine a scenario where an IT operations team is just comfortable with JVM. You also need to deliver a quick five day project and you know that Rails is just the right framework for it. But you do not have the luxury of installing Ruby or even Sqlite on the server.&lt;/p&gt;

&lt;p&gt;Don&amp;#8217;t worry you have JRuby to your resque. You can just ask IT to download the JRuby distribution and set the path to &amp;#8220;JRUBY_HOME&amp;#8221; and add &amp;#8220;$JRUBY_HOME/bin&amp;#8221; to the &amp;#8220;PATH&amp;#8221;. Tell them that at the end of the day its just a jar.&lt;/p&gt;

&lt;p&gt;Now, we need a DB that just runs on JVM, so we use &lt;a href='http://hsqldb.org/'&gt;http://hsqldb.org/&lt;/a&gt;. HSQLDB is a fast, ANSI-SQL compliant DB that runs on JVM.&lt;/p&gt;

&lt;p&gt;Unzip the downloaded HSQLDB distrib, and start the DB with the following command -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -cp /home/rockyj/Apps/hsqldb-2.2.9/hsqldb/lib/hsqldb.jar org.hsqldb.server.Server --database.0 file:dev --dbname.0 dev&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Change the classpath according to your machine. We have named this DB as &amp;#8220;dev&amp;#8221;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now for our Rails app, we can have the following Gemfile -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source &amp;#39;https://rubygems.org&amp;#39;

gem &amp;#39;rails&amp;#39;, &amp;#39;3.2.8&amp;#39;
gem &amp;#39;jquery-rails&amp;#39;
gem &amp;#39;anjlab-bootstrap-rails&amp;#39;, :require =&amp;gt; &amp;#39;bootstrap-rails&amp;#39;
gem &amp;#39;simple_form&amp;#39;

gem &amp;#39;activerecord-jdbchsqldb-adapter&amp;#39;, :git =&amp;gt; &amp;quot;https://github.com/jruby/activerecord-jdbc-adapter&amp;quot;
gem &amp;#39;jruby-openssl&amp;#39;
gem &amp;#39;puma&amp;#39;

group :assets do
  gem &amp;#39;sass-rails&amp;#39;,   &amp;#39;~&amp;gt; 3.2.3&amp;#39;
  gem &amp;#39;coffee-rails&amp;#39;, &amp;#39;~&amp;gt; 3.2.1&amp;#39;
  gem &amp;#39;uglifier&amp;#39;, &amp;#39;&amp;gt;= 1.0.3&amp;#39;
  gem &amp;#39;therubyrhino&amp;#39;
end

group :test, :development do
  gem &amp;#39;rspec-rails&amp;#39;, &amp;#39;~&amp;gt; 2.0&amp;#39;
end

group :test do
  gem &amp;#39;cucumber-rails&amp;#39;, :require =&amp;gt; false
  gem &amp;#39;database_cleaner&amp;#39;
  gem &amp;#39;factory_girl_rails&amp;#39;
  gem &amp;#39;launchy&amp;#39;
  gem &amp;#39;simplecov&amp;#39;
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Main thing to note here is that we are using the master branch for &amp;#8216;activerecord-jdbchsqldb-adapter&amp;#8217; as we are using the latest version of HSQLDB server (all AR tests pass for HSQLDB on master with JRuby so we should be safe).&lt;/p&gt;

&lt;p&gt;Finally here is our database.yml -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;development:
  adapter: jdbc
  driver: org.hsqldb.jdbcDriver
  url: jdbc:hsqldb:hsql://localhost/dev
  username: SA
  password:&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use a similar setup for test and production DBs and we have a Rails app that needs nothing but a JVM to run. Package your gems inside the Rails app for Production and if need be &amp;#8220;warble&amp;#8221; the app or just use Puma / Torquebox. Problem solved!&lt;/p&gt;</content>
  </entry>
</feed>
